const defaultAlgorithm = () =>
  [
    "from AlgorithmImports import *",
    "",
    "class LocalLeanExample(QCAlgorithm):",
    "    def Initialize(self):",
    "        self.SetStartDate(2020, 1, 1)",
    "        self.SetEndDate(2020, 6, 1)",
    "        cash = self.GetParameter('cash') or 100000",
    "        self.SetCash(float(cash))",
    "        symbol = self.GetParameter('symbol') or 'SPY'",
    "        resolution = self.GetParameter('resolution') or 'Minute'",
    "        fee_bps = float(self.GetParameter('feeBps') or 0.5)",
    "        slippage_bps = float(self.GetParameter('slippageBps') or 1)",
    "        self.symbol = self.AddEquity(symbol, self._parse_resolution(resolution)).Symbol",
    "        self.SetSecurityInitializer(lambda sec: self._configure_costs(sec, fee_bps, slippage_bps))",
    "        self.short = self.SMA(self.symbol, 9, Resolution.Daily)",
    "        self.long = self.SMA(self.symbol, 21, Resolution.Daily)",
    "        self.SetWarmup(30)",
    "",
    "    def _parse_resolution(self, value):",
    "        mapping = {",
    "            'tick': Resolution.Tick,",
    "            'second': Resolution.Second,",
    "            'minute': Resolution.Minute,",
    "            'hour': Resolution.Hour,",
    "            'daily': Resolution.Daily,",
    "            'day': Resolution.Daily,",
    "        }",
    "        return mapping.get((value or '').lower(), Resolution.Minute)",
    "",
    "    def _configure_costs(self, security, fee_bps, slippage_bps):",
    "        # bps -> decimal",
    "        fee = float(fee_bps) / 10000.0",
    "        slippage = float(slippage_bps) / 10000.0",
    "        security.SetFeeModel(ConstantFeeModel(fee))",
    "        security.SetSlippageModel(ConstantSlippageModel(slippage))",
    "",
    "    def OnData(self, data: Slice):",
    "        if self.IsWarmingUp:",
    "            return",
    "        if not (self.short.IsReady and self.long.IsReady):",
    "            return",
    "        holdings = self.Portfolio[self.symbol].Quantity",
    "        if holdings <= 0 and self.short.Current.Value > self.long.Current.Value:",
    "            self.SetHoldings(self.symbol, 1)",
    "        elif holdings > 0 and self.short.Current.Value < self.long.Current.Value:",
    "            self.Liquidate(self.symbol)",
  ].join('\\n');

module.exports = { defaultAlgorithm };
